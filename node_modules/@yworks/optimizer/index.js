const util = require('util')
const generate = require('@babel/generator').default
const Mapper = require('./lib/Mapper')

const { parseAst, analyzeUserFiles, analyzeLibFile, logTime, logTimeEnd } = require('./lib/utils')
const parseMappings = require('./lib/parseMappings')
const collectMappings = require('./lib/collectMappings')
const packageModule = require('./lib/packageModule')
const packageFile = require('./lib/packageFile')

const logger = require('./lib/logger')
const myVersion = require('./package.json').version

const notPretty = {
  compact: true
}

const pretty = {}

const defaultOptions = {
  blacklist: [],
  logLevel: 'warn',
  safeMode: false,
  obfuscateBabelSafePublicFields: true
}

module.exports = {
  optimize(libModules, sourceFiles, options) {
    options = Object.assign({}, defaultOptions, options)

    const blacklistSet = new Set(options.blacklist)
    const es6NameMap = new Map()

    logger.level = options.logLevel

    const startTime = Date.now()
    logger.info(
      `Optimizing ${sourceFiles.length} source files and ${libModules.length} yFiles modules using yWorks Optimizer ${myVersion}.`
    )

    logTime('Analyzing lib files')
    const libFiles = libModules.map(libFile => {
      const fileContent = libFile.source

      const ast = parseAst(fileContent)
      const mappingsAstNodes = analyzeLibFile(ast, es6NameMap)

      return {
        size: fileContent.length,
        input: libFile,
        ast,
        mappingsAstNodes
      }
    })
    libFiles.sort((a, b) => a.size - b.size)

    logTimeEnd('Analyzing lib files')

    logTime('Parse mappings')
    const mappings = parseMappings(
      libFiles.map(libFile => libFile.mappingsAstNodes).reduce((acc, val) => acc.concat(val), [])
    )
    logTimeEnd('Parse mappings')

    logger.verbose(`Initial Blacklist: ${util.inspect(blacklistSet, { sorted: true })}`)

    logTime('Collecting mappings')
    const { suggestedMapping, obfuscationNames, dependentNamesMap } = collectMappings(
      blacklistSet,
      mappings
    )
    es6NameMap.forEach(values => values.forEach(value => obfuscationNames.add(value)))

    logger.verbose(
      `Blacklist after parsing modules: ${util.inspect(blacklistSet, { sorted: true })}`
    )

    logTimeEnd('Collecting mappings')

    logTime('Analyzing user files')
    const userFiles = sourceFiles.map(info => {
      const source = info.source
      let ast = null
      try {
        ast = parseAst(source, true)
      } catch (e) {
        let infoString = ''
        try {
          const { source, ...rest } = info
          infoString = JSON.stringify(rest, null, 2)
        } catch (ignore) {
          // ignore
        }

        let text = `Could not parse source: ${e.message}\n\n${infoString}`
        if (e.lineNumber) {
          text += '\n\n'
          const line = source.split('\n')[e.lineNumber - 1]
          text += line.substring(e.column - 30, e.column + 30)
          const caretPos = Math.min(e.column, 30)
          text += '\n' + ' '.repeat(caretPos - 1) + '^\n'
        }
        throw new Error(text)
      }

      return {
        input: info,
        contents: source,
        ast
      }
    })

    const usedNames = analyzeUserFiles(blacklistSet, userFiles)

    logTimeEnd('Analyzing user files')

    logger.verbose(
      `Blacklist after parsing user files: ${util.inspect(blacklistSet, { sorted: true })}`
    )

    const shouldObfuscate = true

    let count
    do {
      count = usedNames.size
      dependentNamesMap.forEach((dependents, key) => {
        if (usedNames.has(key)) {
          for (const dependentName of dependents) {
            usedNames.add(dependentName)
          }
        }
      })
    } while (usedNames.size > count)

    const mapper = new Mapper(
      suggestedMapping,
      blacklistSet,
      obfuscationNames,
      usedNames,
      es6NameMap,
      options.safeMode
    )

    packageModule.init(options.multiLib) // :-)

    if (options.incremental) {
      return {
        nameMap: mapper.mapping,

        optimizeYFilesLibSource(source) {
          const ast = parseAst(source)
          const mappingsAstNodes = analyzeLibFile(ast)
          const info = {
            ast,
            mappingsAstNodes
          }
          packageModule(info, mapper)
          return generate(info.ast, notPretty).code
        },

        optimizeAppSource(source) {
          const ast = parseAst(source, true)
          const info = {
            ast
          }
          packageFile(info, mapper, options.obfuscateBabelSafePublicFields)
          return generate(info.ast, pretty).code
        }
      }
    } else {
      logTime('Optimizing lib files')

      for (const libFile of libFiles) {
        packageModule(libFile, mapper)
        libFile.input.result = generate(libFile.ast, notPretty).code
      }

      logTimeEnd('Optimizing lib files')

      logTime('Optimizing user files')
      for (const userFile of userFiles) {
        if (shouldObfuscate) {
          packageFile(userFile, mapper, options.obfuscateBabelSafePublicFields)
        }
        userFile.input.result = generate(userFile.ast, pretty).code
      }
      logTimeEnd('Optimizing user files')

      if (logger.isDebugEnabled()) {
        require('fs').writeFileSync(
          'yworks-optimizer-mappings.json',
          JSON.stringify([...mapper.mapping.entries()], null, 2)
        )
      }

      const durationSeconds = (Date.now() - startTime) / 1000
      logger.info(`Optimizing done after ${durationSeconds.toFixed(2)} seconds.`)

      return {
        libModules,
        sourceFiles,
        nameMap: mapper.mapping
      }
    }
  },

  defaultOptions
}
