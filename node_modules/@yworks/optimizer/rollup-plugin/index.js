const { optimize, defaultOptions } = require('../index')
const { rollup } = require('rollup')
const logger = require('../lib/logger')
const { isNodeModule, isYfilesModule, shouldIgnore } = require('../lib/plugin-util')

let myInputOptions
let isSecondPass = false

const libSourceMap = new Map()
const appSourceMap = new Map()
const optimizedSources = new Map()

function shouldOptimize(moduleInfo, options) {
  if (options.isYfilesModule(moduleInfo)) {
    return true
  }

  return options.shouldOptimize(moduleInfo) && !shouldIgnore(options, moduleInfo.id)
}

/**
 * @param {RollupPluginOptions} pluginOptions
 */
function YFilesOptimizerRollupPlugin(pluginOptions = {}) {
  pluginOptions = Object.assign(
    {
      ignore: [],
      shouldOptimize: moduleInfo => !isNodeModule(moduleInfo.id),
      isYfilesModule: moduleInfo => isYfilesModule(moduleInfo.id, moduleInfo.code)
    },
    defaultOptions,
    pluginOptions
  )

  return {
    name: 'yworks-optimizer',
    apply: 'build',
    enforce: 'post',

    async buildStart(options) {
      if (!isSecondPass) {
        myInputOptions = options
      } else {
        const libModules = Array.from(libSourceMap.entries()).map(([id, source]) => {
          return {
            id,
            source
          }
        })
        const sourceFiles = Array.from(appSourceMap.entries()).map(([id, source]) => {
          return {
            id,
            source
          }
        })

        logger.verbose(
          `yFiles Modules: ${JSON.stringify(
            libModules.map(m => m.id),
            null,
            2
          )}`
        )
        logger.verbose(
          `Source Files: ${JSON.stringify(
            sourceFiles.map(m => m.id),
            null,
            2
          )}`
        )

        if (libModules.length === 0) {
          this.warn({
            message: 'No yFiles modules found - not optimizing.'
          })
          return
        }

        const { nameMap } = optimize(libModules, sourceFiles, pluginOptions)

        for (const { id, result } of libModules.concat(sourceFiles)) {
          optimizedSources.set(id, result)
        }

        if (logger.levels[logger.level] >= logger.levels.debug) {
          require('fs').writeFileSync(
            'yworks-optimizer-mappings.json',
            JSON.stringify([...nameMap.entries()], null, 2)
          )
        }
      }
    },

    generateBundle(outputOptions, bundle) {
      if (!isSecondPass) {
        for (const key of Object.keys(bundle)) {
          delete bundle[key]
        }
      }
    },

    async writeBundle(outputOptions, bundle) {
      if (!isSecondPass) {
        isSecondPass = true
        const finalBundle = await rollup(myInputOptions)
        await finalBundle.write(outputOptions)
      }
    },

    transform(src, id) {
      if (isSecondPass) {
        if (optimizedSources.has(id)) {
          return optimizedSources.get(id)
        }
      }
    },

    moduleParsed(moduleInfo) {
      if (!isSecondPass) {
        const { id, code } = moduleInfo
        if (pluginOptions.isYfilesModule(moduleInfo)) {
          libSourceMap.set(id, code)
        } else if (shouldOptimize(moduleInfo, pluginOptions)) {
          appSourceMap.set(id, code)
        }
      }
    }
  }
}

module.exports = YFilesOptimizerRollupPlugin
