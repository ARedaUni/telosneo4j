const traverse = require('@babel/traverse').default
const t = require('@babel/types')
const { traverseDecoratorMapping, parseAst } = require('./utils')

// early exit, because traversal is very expensive
// (files are sorted by size)
let es6NameDiffMapFound = false
// prevent early exit, because there might be multiple es6NameDiffMaps to adapt
let multiLib = false

/**
 * Package the set of files that make up a single yFiles module into a target module.
 *
 * @param {object} libFile
 * @param {Mapper} mapper The mapper that stores the mapping
 * @returns {boolean} Whether packaging was successful.
 */
function packageModule(libFile, mapper) {
  // this needs to happen before applyMapping
  obfuscateES6Modules(libFile.ast, mapper)

  // do the obfuscation of the mappings list
  applyMapping(mapper)(libFile.mappingsAstNodes)

  if (!es6NameDiffMapFound || multiLib) {
    obfuscateES6NameDiffMap(libFile.ast, mapper)
  }
}

function obfuscateES6NameDiffMap(ast, mapper) {
  traverse(ast, {
    AssignmentExpression(path) {
      const node = path.node
      if (
        t.isMemberExpression(node.left) &&
        node.left.property.name === 'es6NameDiffMap' &&
        t.isObjectExpression(node.right)
      ) {
        const es6NameMappings = node.right.properties
        for (const es6NameMapping of es6NameMappings) {
          const es5Name = es6NameMapping.key.value.split('.').pop()
          const es6Name = es6NameMapping.value.value

          if (mapper.shouldObfuscate(es5Name)) {
            const mappedEs5Name = mapper.getObfuscatedName(es5Name)
            es6NameMapping.key.value = es6NameMapping.key.value.replace(/[^.]+$/, mappedEs5Name)
          }

          if (mapper.shouldObfuscate(es6Name)) {
            const mappedEs6Name = mapper.getObfuscatedName(es6Name)
            es6NameMapping.value.value = mappedEs6Name
          }
        }

        es6NameDiffMapFound = true
        path.stop()
      }
    }
  })
  traverse.cache.clear()
}

/**
 * Uses the mapper to adjust the mapping information in a mapping object from the AST.
 * Works in place.
 * @param mapper the mapper to obtain the new obfuscated names
 * @returns {applyMapping} the closure to pass to processMap
 */
function applyMapping(mapper) {
  function remap(elem, name) {
    elem[name] = elem[name]
      .split('.')
      .map(n => (mapper.shouldObfuscate(n) ? mapper.getObfuscatedName(n) : n))
      .join('.')
  }

  function applyMapping(maps) {
    for (const { mappingNodes, decoratorNames } of maps) {
      const obfuscateDecoratorVisitor = callExpr => {
        switch (callExpr.callee.name) {
          case decoratorNames.get('OptionArgs'):
            for (const arg of callExpr.arguments) {
              if (t.isLiteral(arg)) {
                remap(arg, 'value')
              }
            }
            break
          case decoratorNames.get('Arg'):
            // Arg(type, name)
            if (
              callExpr.arguments.length > 1 &&
              t.isLiteral(callExpr.arguments[1]) &&
              typeof callExpr.arguments[1].value === 'string'
            ) {
              remap(callExpr.arguments[1], 'value')
              // Arg(type, modifier, name)
            } else if (
              callExpr.arguments.length > 2 &&
              t.isLiteral(callExpr.arguments[2]) &&
              typeof callExpr.arguments[2].value === 'string' &&
              t.isLiteral(callExpr.arguments[1]) &&
              typeof callExpr.arguments[1].value === 'number'
            ) {
              remap(callExpr.arguments[2], 'value')
            }
            break
          case decoratorNames.get('FactoryArg'):
          case decoratorNames.get('ResultFactoryArg'):
            remap(callExpr.arguments[1], 'value')
            remap(callExpr.arguments[0], 'value')
            break
          case decoratorNames.get('SetterArg'):
            remap(callExpr.arguments[0], 'value')
            if (callExpr.arguments.length === 3) {
              remap(callExpr.arguments[2], 'value')
            }
            break
          case decoratorNames.get('CollectionAdderArg'):
            remap(callExpr.arguments[0], 'value')
            remap(callExpr.arguments[1], 'value')
            remap(callExpr.arguments[2], 'value')
            break
          case decoratorNames.get('RestArgs'):
            remap(callExpr.arguments[1], 'value')
            break
        }
      }
      const properties = mappingNodes.properties
      for (let index = 0; index < properties.length; index++) {
        const property = properties[index]

        if (t.isStringLiteral(property.value)) {
          // property without array
          property.value.value = mapper.getObfuscatedName(property.value.value)
        } else {
          let elementsParent
          if (t.isObjectMethod(property)) {
            // getter property
            elementsParent = property.body.body[0].argument
          } else if (t.isArrayExpression(property.value)) {
            // simple value property
            elementsParent = property.value
          }
          const elements = elementsParent.elements

          const hasDecorator = t.isCallExpression(elements[elements.length - 1])
          const isOverloadDecorator = hasDecorator && elements.length === 2

          const clearName = isOverloadDecorator ? elements[1].arguments[0].value : elements[0].value
          const shortName = elements[elements.length - (hasDecorator ? 2 : 1)].value

          // YJS-4275
          let forceKeep = false
          if (hasDecorator) {
            const callee = elements[elements.length - 1].callee
            if (
              t.isMemberExpression(callee) &&
              t.isIdentifier(callee.property, { name: 'Es6Iterator' })
            ) {
              forceKeep = mapper.isUsed('iterator')
            }
          }

          if (!forceKeep && !mapper.isUsed(clearName) && mapper.shouldObfuscate(clearName)) {
            // we neither need a clearName nor a decorator
            if (t.isObjectMethod(property)) {
              properties[index] = t.objectProperty(property.key, t.stringLiteral(shortName))
            } else {
              property.value = t.stringLiteral(shortName)
            }
          } else {
            const mapped = mapper.shouldObfuscate(clearName)
              ? mapper.getObfuscatedName(clearName)
              : clearName
            const newName = mapped || clearName

            const same = newName === shortName
            const newEntry = t.stringLiteral(newName)

            if (isOverloadDecorator) {
              // replace overloadName
              elements[1].arguments[0] = newEntry
            } else if (!same && elements.length === (hasDecorator ? 2 : 1)) {
              // single name !== newName
              elements.unshift(newEntry)
              elementsParent.elements = elements
            } else if (same && !hasDecorator) {
              property.value = newEntry
            } else if (same && hasDecorator && elements.length > 2) {
              elementsParent.elements = elements.slice(1)
            } else {
              elements[0] = newEntry
            }

            if (hasDecorator) {
              traverseDecoratorMapping(elements[elements.length - 1], obfuscateDecoratorVisitor)
            }
          }
        }
      }
    }
  }
  return applyMapping
}

/**
 * Obfuscate export statements
 * @param  fileAst
 * @param {Mapper} mapper
 */
function obfuscateES6Modules(fileAst, mapper) {
  function remap(elem, name) {
    if (mapper.shouldObfuscate(elem[name])) {
      elem[name] = mapper.getObfuscatedName(elem[name])
    }
  }

  function remapMemberExpression(memberExpression) {
    if (t.isMemberExpression(memberExpression.object)) {
      remapMemberExpression(memberExpression.object)
    } else if (t.isIdentifier(memberExpression.object)) {
      remap(memberExpression.object, 'name')
    }
    remap(memberExpression.property, 'name')
  }

  const body = fileAst.program.body
  for (const node of body) {
    if (t.isExportNamedDeclaration(node) && node.declaration && node.declaration.declarations) {
      for (const variableDeclarator of node.declaration.declarations) {
        remap(variableDeclarator.id, 'name')
        remapMemberExpression(variableDeclarator.init)
      }
    }
  }
}

packageModule.init = isMultiLib => {
  multiLib = isMultiLib
  es6NameDiffMapFound = false
}

module.exports = packageModule
