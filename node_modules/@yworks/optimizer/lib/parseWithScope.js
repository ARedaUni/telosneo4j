const traverse = require('@babel/traverse').default
const logger = require('./logger')
const ObfuscationScopeInfo = require('./ObfuscationScopeInfo')

/**
 * Finds the corresponding ObfuscationScopeInfo for the given range (of an AST node).
 *
 * @param {number[]} range The range in question.
 * @param {ObfuscationScopeInfo} parentScopeInfo The root info that contains information about the tree the ast resides
 *   in.
 * @returns {ObfuscationScopeInfo} The info to apply.
 */
function getObfuscationScopeInfo(range, parentScopeInfo) {
  if (!range || !parentScopeInfo || !parentScopeInfo.isInRange(range)) {
    return ObfuscationScopeInfo.DEFAULT
  }
  for (const child of parentScopeInfo.children) {
    if (child.isInRange(range)) {
      return getObfuscationScopeInfo(range, child)
    }
  }
  return parentScopeInfo
}

/**
 * AST visitor that annotates the AST nodes with ObfuscationScopeInfo instances and then invokes the given visitor.
 *
 * @param {object} ast The AST.
 * @param {ObfuscationScopeInfo} rootObfuscationInfo The root ObfuscationScopeInfo.
 * @param {function} visitor
 */
module.exports = function parseWithScope(ast, rootObfuscationInfo, visitor) {
  rootObfuscationInfo = rootObfuscationInfo || ObfuscationScopeInfo.DEFAULT
  let bodyObfuscationInfo

  traverse(ast, {
    enter({ node, parent }) {
      const parentObfuscationInfo =
        (parent && parent.obfuscationInfo) ||
        getObfuscationScopeInfo(node.range, rootObfuscationInfo)
      node.obfuscationInfo = createScopeObfuscationInfo(node, parentObfuscationInfo)
      if (parent === null) {
        bodyObfuscationInfo = node.obfuscationInfo
      }
      visitor(node, parent)
    },
    exit({ node }) {
      if (node.obfuscationInfo) {
        delete node.obfuscationInfo
      }
    }
  })

  traverse.cache.clear()

  return bodyObfuscationInfo

  /**
   * Returns a ScopeObfuscationInfo for the current node. If the current node has no scope annotations, this is the
   * parent scope. Otherwise, a new scope object is created.
   */
  function createScopeObfuscationInfo(node, parentScopeInfo) {
    const comments = node.leadingComments
    if (!comments || comments.length < 0) {
      return parentScopeInfo
    }

    let currentScope = parentScopeInfo

    for (const comment of comments.map(c => c.value)) {
      let newScope
      if ((newScope = checkForKeepAnnotation(comment))) {
        currentScope = newScope
      }
      if ((newScope = checkForBlacklistAnnotation(comment))) {
        currentScope = newScope
      }
      if (/@yjs:\s*(unsafe|exclude)/g.exec(comment)) {
        return parentScopeInfo.addChildInfo(ObfuscationScopeInfo.MODE_BLACKLIST, node.range)
      }
      let results
      if ((results = /@yjs:\s*obfuscate\s+exclude\s*=\s*(.+)/g.exec(comment))) {
        addElements(results[1], el => parentScopeInfo.addGlobalBlackListItem(el))
      }
    }

    return currentScope

    function checkForKeepAnnotation(comment) {
      let matchResults
      if (!(matchResults = /@yjs:\s*keep(\s*=\s*(.+))?/g.exec(comment))) {
        return null
      }
      if (matchResults.length < 3 || !matchResults[2]) {
        // keep without list of names > keep all elements inside this scope
        return parentScopeInfo.addChildInfo(ObfuscationScopeInfo.MODE_KEEP, node.range)
      }
      // list of elements to keep inside this scope
      const scope = parentScopeInfo.addChildInfo(ObfuscationScopeInfo.MODE_OBFUSCATE, node.range)

      logger.debug(`Found keep comment ${matchResults[2]}`)

      addElements(matchResults[2], el => scope.addBlackListItem(el))
      return scope
    }

    function checkForBlacklistAnnotation(comment) {
      let matchResults
      if (!(matchResults = /@yjs:\s*blacklist(\s*=\s*(.+))?/g.exec(comment))) {
        return null
      }
      if (matchResults.length < 3 || !matchResults[2]) {
        // add all elements from this scope to the global blacklist -> this is done in the Usage Visitor
        return parentScopeInfo.addChildInfo(ObfuscationScopeInfo.MODE_BLACKLIST, node.range)
      }
      // list of elements to add to the global blacklist
      addElements(matchResults[2], el => parentScopeInfo.addGlobalBlackListItem(el))
      return null
    }

    function addElements(list, f) {
      if (list) {
        const elements = list.split(/\s*,\s*/)
        if (elements) {
          for (const el of elements) {
            if (el && el.length > 0) {
              f(el)
            }
          }
        }
      }
    }
  }
}
