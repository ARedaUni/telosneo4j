const logger = require('./logger')

module.exports = function collectMappings(blacklistSet, mappings) {
  const dependentNamesMap = new Map()

  //
  // We could also take not of the extra arg names, to determine which dependent
  // names need to be marked as used - YJS-4691
  //
  for (const values of mappings.values()) {
    if (values && values.dependentNames) {
      const longName = values.length > 0 && values[0]
      const oldNames = dependentNamesMap.get(longName)
      if (oldNames) {
        dependentNamesMap.set(longName, oldNames.concat(values.dependentNames))
      } else {
        dependentNamesMap.set(longName, values.dependentNames)
      }
    }
  }

  // The map that contains the proposed names for the items that can be
  // renamed. This is populated by default with the names used internally by the library
  // they are guaranteed to not conflict with each other, so they make a good name
  const suggestedMapping = new Map()
  // the names that will possibly be renamed by this task
  const obfuscationNames = new Set()

  // generate the suggested mapping and collect blacklist items
  mappings.forEach((values, key) => {
    const longName = values && values.length > 0 && values[0]
    const shortName = values && values.length > 1 && values[1]

    const hasDecorator = values.hasDecorator

    if (longName && suggestedMapping.has(longName)) {
      // we have stored a short name for this long name already
      // it is used elsewhere, so we cannot map it to the same value if it uses a different short name
      if (suggestedMapping.get(longName) !== shortName) {
        suggestedMapping.set(longName, null)
      }
    } else {
      if (hasDecorator) {
        // this is a decorator - so we may not always use the shortname for the longname, because that would yield a clash
        // so we mark the name as not being available as a suggested short name
        suggestedMapping.set(longName, null)
      } else if (shortName) {
        // suggest the short name for the resulting name, since this will create a smaller mapping file and leaner
        // object at runtime with less properties. If there is a decorator we must NOT suggest a mapping, as we need
        // two names for decorators to work.
        suggestedMapping.set(longName, shortName)
      }
    }
    // see if the key is marked with the special "no obfuscation allowed" prefix.
    // these names are used "reflectively" and may not be changed.
    if (key.startsWith('_$$_')) {
      // add it to the global blacklist.
      blacklistSet.add(longName)

      // if the name is actually a namespace name, it can contain dots - add all name parts to the exclusion:
      if (longName.includes('.')) {
        for (const item of longName.split('.')) {
          blacklistSet.add(item)
        }
      }
    } else {
      // this is a name that may possibly be obfuscated later on
      obfuscationNames.add(longName)
    }
  })

  // for items on the blacklist, remove them from the possible obfuscation set
  for (const item of blacklistSet) {
    obfuscationNames.delete(item)
  }

  logger.debug(`Found ${mappings.size} mappings.`)
  logger.debug(`Found ${blacklistSet.size} blacklisted names.`)
  logger.debug(`Dependent names:\n${JSON.stringify([...dependentNamesMap.entries()])}`)

  return {
    suggestedMapping,
    obfuscationNames,
    dependentNamesMap
  }
}
