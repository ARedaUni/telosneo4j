const { parse } = require('@babel/parser')
const traverse = require('@babel/traverse').default
const t = require('@babel/types')
const ObfuscationScopeInfo = require('./ObfuscationScopeInfo')
const parseWithScope = require('./parseWithScope')

const logger = require('./logger')

/**
 * Since the parser doesn't attach comment by itself, we attach them here, for the whole AST.
 * We attach comments as leading comments *only*, since this is the only information we use.
 */
function attachComments(ast) {
  const comments = ast.comments
  ast.trailingComments = []
  const allNodes = []
  let i = 0
  traverse(ast, {
    enter({ node }) {
      node.stabilityIndex = ++i
      allNodes.push(node)
    }
  })
  traverse.cache.clear()
  comments.sort((a, b) => b.start - a.start)
  allNodes.sort((a, b) => {
    const delta = a.start - b.start
    if (delta === 0) {
      return a.stabilityIndex - b.stabilityIndex
    }
    return delta
  })
  // TODO: possible improvement: don't iterate all nodes each time, start where the last loop stopped
  for (const comment of comments) {
    const commentEnd = comment.end
    let i = 0
    // find the first node that comes after this comment ends
    while (i < allNodes.length && allNodes[i].start < commentEnd) {
      i += 1
    }
    // attach to body if no suitable node found?
    if (i < allNodes.length) {
      const nodeToAttach = allNodes[i]
      if (!nodeToAttach.leadingComments) {
        nodeToAttach.leadingComments = []
      }
      nodeToAttach.leadingComments.push(comment)
    } else {
      ast.trailingComments.push(comment)
    }
  }
}

/**
 * Finds the line "yfiles.lang.addMappings(version, map, override) in a module file and returns
 * that element.
 */
function findMappingAstNodes(path) {
  const { node, parent } = path
  if (
    t.isExpressionStatement(node) &&
    t.isCallExpression(node.expression) &&
    t.isMemberExpression(node.expression.callee) &&
    node.expression.callee.property.name === 'addMappings' &&
    node.expression.arguments.length >= 2
  ) {
    const owner = node.expression.callee.object
    if (
      t.isIdentifier(owner, { name: 'lang' }) ||
      (t.isMemberExpression(owner) &&
        owner.property.name === 'lang' &&
        t.isLiteral(node.expression.arguments[0]) &&
        t.isObjectExpression(node.expression.arguments[1]))
    ) {
      const nameMap = new Map()
      const previousSibling = parent.body.find((a, i, arr) => arr[i + 1] === node)
      if (previousSibling && t.isVariableDeclaration(previousSibling)) {
        previousSibling.declarations.forEach(({ id, init }) => {
          let memberExpression = null
          if (t.isMemberExpression(init)) {
            memberExpression = init
          } else if (t.isSequenceExpression(init)) {
            const last = init.expressions[init.expressions.length - 1]
            if (t.isMemberExpression(last)) {
              memberExpression = last
            }
          }
          if (memberExpression) {
            nameMap.set(memberExpression.property.name, id.name)
          } else {
            throw new Error('Unexpected decorator variable declaration type ' + init.type)
          }
        })
      }
      return {
        mappingNodes: node.expression.arguments[1],
        decoratorNames: nameMap
      }
    }
  }
}

function collectEs6Names(es6NameMap, { node }) {
  // ES6 lib: collect exports
  if (t.isExportNamedDeclaration(node) && node.declaration && node.declaration.declarations) {
    for (const variableDeclarator of node.declaration.declarations) {
      const es6Name = variableDeclarator.id.name
      const es5Name = variableDeclarator.init.property.name
      if (es6Name !== es5Name) {
        // this is an alternate es6 name for a duplicate identifier
        if (es6NameMap.has(es5Name)) {
          es6NameMap.get(es5Name).push(es6Name)
        } else {
          es6NameMap.set(es5Name, [es6Name])
        }
      }
    }
  }
  // UMD lib: analyze es6NameDiffMap in lang
  else if (
    t.isAssignmentExpression(node) &&
    t.isMemberExpression(node.left) &&
    node.left.property.name === 'es6NameDiffMap' &&
    t.isObjectExpression(node.right)
  ) {
    const es6NameMappings = node.right.properties
    for (const es6NameMapping of es6NameMappings) {
      const es5Name = es6NameMapping.key.value.split('.').pop()
      const es6Name = es6NameMapping.value.value

      if (es6NameMap.has(es5Name)) {
        es6NameMap.get(es5Name).push(es6Name)
      } else {
        es6NameMap.set(es5Name, [es6Name])
      }
    }
  }
}

//  manual "traversal" for decorator mappings, because babel traverse is very slow
function traverseDecoratorMapping(callExpr, visit) {
  visit(callExpr)
  for (const arg of callExpr.arguments) {
    if (t.isCallExpression(arg) && t.isIdentifier(arg.callee)) {
      traverseDecoratorMapping(arg, visit)
    }
  }
}

module.exports = {
  traverseDecoratorMapping,

  analyzeLibFile(ast, es6NameMap) {
    const mapAstElements = []

    traverse(ast, {
      enter(path) {
        const mappingAstInfo = findMappingAstNodes(path)
        if (mappingAstInfo) {
          if (mappingAstInfo.decoratorNames.size === 0) {
            throw new Error(
              `yWorks Optimizer: Could not process the yFiles library modules. Make sure not to optimize the debug library.`
            )
          }
          mapAstElements.push(mappingAstInfo)
        }
        if (es6NameMap) {
          collectEs6Names(es6NameMap, path)
        }
      }
    })

    traverse.cache.clear()

    return mapAstElements
  },

  parseAst(codeString, isUserSource = false) {
    const options = {
      sourceType: 'script'
    }
    if (isUserSource) {
      options.ranges = true
      options.tokens = true
    }
    let ast
    try {
      ast = parse(codeString, options)
    } catch (e) {
      try {
        // try parsing as a module
        options.sourceType = 'module'
        ast = parse(codeString, options)
      } catch (e) {
        console.error('Could not parse ast')
        throw e
      }
    }

    if (isUserSource) {
      attachComments(ast)
    }

    return ast
  },

  /** Collects names used in client code Javascript files. */
  analyzeUserFiles(blacklistSet, userFiles) {
    const shouldObfuscate = true

    const usedNames = new Set()

    for (const userFile of userFiles) {
      collectUsages(userFile, blacklistSet, shouldObfuscate)
    }

    return usedNames

    function collectUsages(userFile, blacklistSet, shouldObfuscate) {
      const { ast } = userFile

      const rootScope = new ObfuscationScopeInfo(
        shouldObfuscate ? ObfuscationScopeInfo.MODE_OBFUSCATE : ObfuscationScopeInfo.MODE_BLACKLIST
      )
      rootScope.globalBlackList = blacklistSet
      parseWithScope(ast, rootScope, usageVisitor)

      function usageVisitor(node, parent) {
        let name
        if (t.isIdentifier(node)) {
          name = node.name
        } else if (t.isStringLiteral(node)) {
          name = node.value
        }
        if (name) {
          usedNames.add(name)
          if (node.obfuscationInfo.obfuscationMode === ObfuscationScopeInfo.MODE_BLACKLIST) {
            blacklistSet.add(name)
          }
        }
      }
    }
  },

  logTime(label) {
    if (logger.isDebugEnabled()) {
      console.time(label)
    }
  },

  logTimeEnd(label) {
    if (logger.isDebugEnabled()) {
      console.timeEnd(label)
    }
  }
}
