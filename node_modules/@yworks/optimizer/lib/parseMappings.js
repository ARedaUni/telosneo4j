const t = require('@babel/types')
const { traverseDecoratorMapping } = require('./utils')

module.exports = function parseMappings(mappingsAsts) {
  const mappings = new Map()
  const dependentNames = []

  for (const { mappingNodes, decoratorNames } of mappingsAsts) {
    const dependentMappingsDecoratorVisitor = callExpr => {
      function addToDependentNames(names) {
        dependentNames.push(...names.split('.'))
      }

      switch (callExpr.callee.name) {
        case decoratorNames.get('FactoryArg'):
        case decoratorNames.get('ResultFactoryArg'):
          addToDependentNames(callExpr.arguments[1].value)
          break
        case decoratorNames.get('SetterArg'):
          if (callExpr.arguments.length === 3) {
            addToDependentNames(callExpr.arguments[2].value)
          }
          break
        case decoratorNames.get('CollectionAdderArg'):
          addToDependentNames(callExpr.arguments[1].value)
          addToDependentNames(callExpr.arguments[2].value)
          break
      }
    }

    const properties = mappingNodes.properties

    for (let index = 0; index < properties.length; index++) {
      const property = properties[index]
      dependentNames.length = 0
      let names
      let hasDecorator = false

      const key = t.isLiteral(property.key) ? property.key.value : property.key.name

      if (t.isObjectMethod(property)) {
        const elements = property.body.body[0].argument.elements
        if (elements.length === 2) {
          // overload decorator -> extract clear name from first argument
          names = [elements[1].arguments[0], elements[0]]
        } else {
          names = elements.slice(0, -1) // remove decorator
        }
        hasDecorator = true
      }

      if (t.isLiteral(property.value)) {
        names = [property.value]
      } else if (t.isArrayExpression(property.value)) {
        names = property.value.elements
      }

      names = names.map(entry => entry.value)

      if (hasDecorator) {
        // get _$_uqh() {
        //   return ['$zYa', mi('moveToLast', 0, Ei('yfiles._R.C.CXA'))]
        // },
        // property is a getter (ObjectMethod) => we need the inner callexpression ("mi" above)
        const args = property.body.body[0].argument.elements
        traverseDecoratorMapping(args[args.length - 1], dependentMappingsDecoratorVisitor)

        if (dependentNames.length > 0) {
          names.dependentNames = dependentNames.slice(0)
        }
      }

      names.hasDecorator = hasDecorator

      mappings.set(key, names)
    }
  }
  return mappings
}
