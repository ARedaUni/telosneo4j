const path = require('path')
const logger = require('../lib/logger')
const minimatch = require('minimatch')
const { defaultOptions, optimize } = require('../index')
const { URLSearchParams } = require('url')
const { shouldIgnore, isNodeModule, isYfilesModule } = require('../lib/plugin-util')

const PLUGIN_NAME = 'yFiles Optimizer Plugin'

function getOriginalSource(module) {
  if (typeof module.originalSource === 'function') {
    const source = module.originalSource()
    if (source && typeof source.source === 'function') {
      return source.source()
    }
  }
  return null
}

function shouldRebuild(module) {
  return (
    module.resource &&
    module.type.startsWith('javascript/') &&
    module._source &&
    typeof module._source.source === 'function' &&
    !module.loaders.some(loader => /node_modules[/\\]worker-loader/.test(loader.loader))
  )
}

function rebuildModule(compilation, module) {
  return new Promise((resolve, reject) => {
    let reasons = null
    if (module.reasons) {
      reasons = module.reasons.slice(0)
    }

    compilation.rebuildModule(module, error => {
      if (error) {
        return reject(error)
      }

      // webpack < 5: If we don't restore reasons manually, entrypoint multi-module
      // reasons will be empty after rebuild.
      if (reasons) {
        module.reasons = reasons
      }
      resolve()
    })
  })
}

function getModuleSource(module) {
  return module._source.source()
}

function getRootCompiler(compiler) {
  let rootCompiler = compiler
  while (rootCompiler.parentCompilation) {
    rootCompiler = compiler.parentCompilation
  }
  return rootCompiler
}

class YFilesOptimizerWebpackPlugin {
  constructor(options) {
    this.options = Object.assign(
      {
        ignore: [],
        shouldOptimize: module => !isNodeModule(module.resource),
        isYfilesModule: module => isYfilesModule(module.resource, getOriginalSource(module))
      },
      defaultOptions,
      options,
      {
        incremental: true
      }
    )

    logger.level = this.options.logLevel
  }

  // YJS-7187
  fixAngularCompilerPluginIssue(compiler) {
    const rootCompiler = getRootCompiler(compiler)
    const hasAngularPlugin =
      rootCompiler.options &&
      rootCompiler.options.plugins &&
      rootCompiler.options.plugins.some(p => p.constructor && /angular/i.test(p.constructor.name))
    if (hasAngularPlugin) {
      this.options.blacklist.push('run', 'update', 'template')
      logger.info(
        'Angular webpack plugin found - enabling watchMode to prevent compiler reset during rebuild'
      )
      rootCompiler.watchMode = true
    }
  }

  fixCachingIssue(compiler) {
    const rootCompiler = getRootCompiler(compiler)
    const isFilesystemCacheEnabled =
      rootCompiler.options &&
      typeof rootCompiler.options.cache === 'object' &&
      rootCompiler.options.cache.type === 'filesystem'
    if (isFilesystemCacheEnabled) {
      logger.warn("Optimizer does not support webpack's filesystem cache - disabling it.")
      rootCompiler.options.cache = false
    }
  }

  apply(compiler) {
    this.fixCachingIssue(compiler)
    this.fixAngularCompilerPluginIssue(compiler)

    compiler.hooks.compilation.tap(PLUGIN_NAME, compilation => {
      compilation.hooks.finishModules.tapPromise(PLUGIN_NAME, async modules => {
        return this.obfuscateModules(compilation)
      })
    })
  }

  async obfuscateModules(compilation) {
    const startTime = Date.now()
    const modulesArr = Array.isArray(compilation.modules)
      ? // webpack < 5
        compilation.modules
      : // webpack >= 5
        Array.from(compilation.modules)
    const rebuildModules = modulesArr.filter(shouldRebuild)
    const modulesToOptimize = rebuildModules.filter(module => this.shouldOptimize(module))
    const yFilesModules = modulesToOptimize.filter(module => this.options.isYfilesModule(module))

    if (yFilesModules.length === 0) {
      return
    }

    logger.verbose(`Rebuilding ${rebuildModules.length} modules.`)

    const userModules = modulesToOptimize.filter(
      module => this.options.shouldOptimize(module) && !this.options.isYfilesModule(module)
    )

    logger.silly(
      `Rebuild Modules: ${JSON.stringify(
        rebuildModules.map(m => m.resource),
        null,
        2
      )}`
    )

    logger.verbose(
      `yFiles Modules: ${JSON.stringify(
        yFilesModules.map(m => m.resource),
        null,
        2
      )}`
    )
    logger.verbose(
      `Source Files: ${JSON.stringify(
        userModules.map(m => m.resource),
        null,
        2
      )}`
    )

    if (yFilesModules.length === 0) {
      compilation.warnings.push(
        new Error(
          `${PLUGIN_NAME}: No yFiles modules found${
            compilation.name ? ` in module ${compilation.name}` : ''
          }`
        )
      )
    }

    function toOptimizerInput(module) {
      const source = getModuleSource(module)
      return {
        source,
        resourcePath: module.resource
      }
    }

    const { optimizeYFilesLibSource, optimizeAppSource, nameMap } = optimize(
      yFilesModules.map(toOptimizerInput),
      userModules.map(toOptimizerInput),
      this.options
    )

    const dependencies = {}

    rebuildModules.forEach(module => {
      module.dependencies &&
        module.dependencies.forEach(dep => {
          const mod = compilation.moduleGraph
            ? // webpack >= 5
              compilation.moduleGraph.getModule(dep)
            : // webpack < 5
              dep.module
          if (mod && module !== mod && rebuildModules.includes(mod)) {
            if (!dependencies[module.resource]) {
              dependencies[module.resource] = []
            }
            if (!dependencies[module.resource].includes(mod.resource)) {
              dependencies[module.resource].push(mod.resource)
            }
          }
        })
    })

    let leaves = rebuildModules.filter(m => !dependencies.hasOwnProperty(m.resource))

    async function processModule(module) {
      if (modulesToOptimize.includes(module)) {
        const optimizerInput = getModuleSource(module)
        const optimizedSource = yFilesModules.includes(module)
          ? optimizeYFilesLibSource(optimizerInput)
          : optimizeAppSource(optimizerInput)
        module.loaders.unshift({
          options: {
            optimizedSource
          },
          loader: path.join(__dirname, 'loader.js')
        })

        await rebuildModule(compilation, module)
      } else {
        await rebuildModule(compilation, module)
      }
    }

    while (leaves.length) {
      for (const leafModule of leaves) {
        await processModule(leafModule)

        rebuildModules.splice(rebuildModules.indexOf(leafModule), 1)

        // Remove rebuilt module from dependencies map
        Object.values(dependencies).forEach(deps => {
          const index = deps.indexOf(leafModule.resource)
          if (index > -1) {
            deps.splice(index, 1)
          }
        })
      }

      Object.entries(dependencies).forEach(([key, value]) => {
        if (!value.length) {
          delete dependencies[key]
        }
      })

      leaves = rebuildModules.filter(m => !dependencies.hasOwnProperty(m.resource))
    }

    const circulars = Object.keys(dependencies)
    if (circulars.length) {
      const circularModules = rebuildModules.filter(m => circulars.includes(m.resource))

      for (const module of circularModules) {
        await processModule(module)
      }
    }

    for (const module of modulesToOptimize) {
      if (module.buildMeta && Array.isArray(module.buildMeta.providedExports)) {
        module.buildMeta.providedExports = module.buildMeta.providedExports.map(
          exp => nameMap.get(exp) || exp
        )
      }
    }

    if (logger.levels[logger.level] >= logger.levels.debug) {
      require('fs').writeFileSync(
        'yworks-optimizer-mappings.json',
        JSON.stringify([...nameMap.entries()], null, 2)
      )
    }

    const durationSeconds = (Date.now() - startTime) / 1000
    logger.info(`Optimizing done after ${durationSeconds.toFixed(2)} seconds.`)
  }

  shouldIgnore(module) {
    const modulePath = module.resource
    if (modulePath) {
      if (modulePath.includes('?')) {
        try {
          const searchParams = new URLSearchParams(modulePath.replace(/.*?\?/, ''))
          if (searchParams.has('type')) {
            const type = searchParams.get('type')
            return type !== 'script'
          }
        } catch (e) {
          console.log(e)
        }
      }

      return shouldIgnore(this.options, modulePath)
    }

    return false
  }

  shouldOptimize(module) {
    if (this.options.isYfilesModule(module)) {
      return true
    }

    return this.options.shouldOptimize(module) && !this.shouldIgnore(module)
  }
}

module.exports = YFilesOptimizerWebpackPlugin
